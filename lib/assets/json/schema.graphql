schema {
    query: query_root
    subscription: subscription_root
  }
  "whether this query should be cached (Hasura Cloud only)"
  directive @cached("measured in seconds" ttl: Int! = 60, "refresh the cache entry" refresh: Boolean! = false) on QUERY
  """
  Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
  """
  input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
  }
  """
  Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
  """
  input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
  }
  """
  Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
  """
  input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
  }
  """
  columns and relationships of "allowlists"
  """
  type allowlists {
    accountId: String!
    contractId: String
    createdAt: timestamptz!
    id: String!
    txId: String!
  }
  """
  aggregated selection of "allowlists"
  """
  type allowlists_aggregate {
    aggregate: allowlists_aggregate_fields
    nodes: [allowlists!]!
  }
  """
  aggregate fields of "allowlists"
  """
  type allowlists_aggregate_fields {
    count(columns: [allowlists_select_column!], distinct: Boolean): Int!
    max: allowlists_max_fields
    min: allowlists_min_fields
  }
  """
  Boolean expression to filter rows from the table "allowlists". All fields are combined with a logical 'AND'.
  """
  input allowlists_bool_exp {
    _and: [allowlists_bool_exp!]
    _not: allowlists_bool_exp
    _or: [allowlists_bool_exp!]
    accountId: String_comparison_exp
    contractId: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    id: String_comparison_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type allowlists_max_fields {
    accountId: String
    contractId: String
    createdAt: timestamptz
    id: String
    txId: String
  }
  "aggregate min on columns"
  type allowlists_min_fields {
    accountId: String
    contractId: String
    createdAt: timestamptz
    id: String
    txId: String
  }
  """
  Ordering options when selecting data from "allowlists".
  """
  input allowlists_order_by {
    accountId: order_by
    contractId: order_by
    createdAt: order_by
    id: order_by
    txId: order_by
  }
  """
  select columns of table "allowlists"
  """
  enum allowlists_select_column {
    "column name"
    accountId
    "column name"
    contractId
    "column name"
    createdAt
    "column name"
    id
    "column name"
    txId
  }
  """
  columns and relationships of "approvals"
  """
  type approvals {
    accountId: String
    createdAt: timestamptz!
    id: String!
    tokenKey: String
    txId: String!
  }
  """
  aggregated selection of "approvals"
  """
  type approvals_aggregate {
    aggregate: approvals_aggregate_fields
    nodes: [approvals!]!
  }
  """
  aggregate fields of "approvals"
  """
  type approvals_aggregate_fields {
    count(columns: [approvals_select_column!], distinct: Boolean): Int!
    max: approvals_max_fields
    min: approvals_min_fields
  }
  """
  order by aggregate values of table "approvals"
  """
  input approvals_aggregate_order_by {
    count: order_by
    max: approvals_max_order_by
    min: approvals_min_order_by
  }
  """
  Boolean expression to filter rows from the table "approvals". All fields are combined with a logical 'AND'.
  """
  input approvals_bool_exp {
    _and: [approvals_bool_exp!]
    _not: approvals_bool_exp
    _or: [approvals_bool_exp!]
    accountId: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    id: String_comparison_exp
    tokenKey: String_comparison_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type approvals_max_fields {
    accountId: String
    createdAt: timestamptz
    id: String
    tokenKey: String
    txId: String
  }
  """
  order by max() on columns of table "approvals"
  """
  input approvals_max_order_by {
    accountId: order_by
    createdAt: order_by
    id: order_by
    tokenKey: order_by
    txId: order_by
  }
  "aggregate min on columns"
  type approvals_min_fields {
    accountId: String
    createdAt: timestamptz
    id: String
    tokenKey: String
    txId: String
  }
  """
  order by min() on columns of table "approvals"
  """
  input approvals_min_order_by {
    accountId: order_by
    createdAt: order_by
    id: order_by
    tokenKey: order_by
    txId: order_by
  }
  """
  Ordering options when selecting data from "approvals".
  """
  input approvals_order_by {
    accountId: order_by
    createdAt: order_by
    id: order_by
    tokenKey: order_by
    txId: order_by
  }
  """
  select columns of table "approvals"
  """
  enum approvals_select_column {
    "column name"
    accountId
    "column name"
    createdAt
    "column name"
    id
    "column name"
    tokenKey
    "column name"
    txId
  }
  """
  columns and relationships of "banlists"
  """
  type banlists {
    accountId: String!
    contractId: String
    createdAt: timestamptz!
    id: String!
    txId: String!
  }
  """
  aggregated selection of "banlists"
  """
  type banlists_aggregate {
    aggregate: banlists_aggregate_fields
    nodes: [banlists!]!
  }
  """
  aggregate fields of "banlists"
  """
  type banlists_aggregate_fields {
    count(columns: [banlists_select_column!], distinct: Boolean): Int!
    max: banlists_max_fields
    min: banlists_min_fields
  }
  """
  Boolean expression to filter rows from the table "banlists". All fields are combined with a logical 'AND'.
  """
  input banlists_bool_exp {
    _and: [banlists_bool_exp!]
    _not: banlists_bool_exp
    _or: [banlists_bool_exp!]
    accountId: String_comparison_exp
    contractId: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    id: String_comparison_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type banlists_max_fields {
    accountId: String
    contractId: String
    createdAt: timestamptz
    id: String
    txId: String
  }
  "aggregate min on columns"
  type banlists_min_fields {
    accountId: String
    contractId: String
    createdAt: timestamptz
    id: String
    txId: String
  }
  """
  Ordering options when selecting data from "banlists".
  """
  input banlists_order_by {
    accountId: order_by
    contractId: order_by
    createdAt: order_by
    id: order_by
    txId: order_by
  }
  """
  select columns of table "banlists"
  """
  enum banlists_select_column {
    "column name"
    accountId
    "column name"
    contractId
    "column name"
    createdAt
    "column name"
    id
    "column name"
    txId
  }
  scalar bigint
  """
  Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
  """
  input bigint_comparison_exp {
    _eq: bigint
    _gt: bigint
    _gte: bigint
    _in: [bigint!]
    _is_null: Boolean
    _lt: bigint
    _lte: bigint
    _neq: bigint
    _nin: [bigint!]
  }
  """
  columns and relationships of "earnings"
  """
  type earnings {
    amount: numeric!
    contractId: String!
    createdAt: timestamptz!
    groupId: String!
    id: String!
    "An object relationship"
    list: lists
    listId: String!
    offerId: String
    receiverId: String!
    "An object relationship"
    token: tokens
    tokenKey: String!
  }
  """
  aggregated selection of "earnings"
  """
  type earnings_aggregate {
    aggregate: earnings_aggregate_fields
    nodes: [earnings!]!
  }
  """
  aggregate fields of "earnings"
  """
  type earnings_aggregate_fields {
    avg: earnings_avg_fields
    count(columns: [earnings_select_column!], distinct: Boolean): Int!
    max: earnings_max_fields
    min: earnings_min_fields
    stddev: earnings_stddev_fields
    stddev_pop: earnings_stddev_pop_fields
    stddev_samp: earnings_stddev_samp_fields
    sum: earnings_sum_fields
    var_pop: earnings_var_pop_fields
    var_samp: earnings_var_samp_fields
    variance: earnings_variance_fields
  }
  "aggregate avg on columns"
  type earnings_avg_fields {
    amount: Float
  }
  """
  Boolean expression to filter rows from the table "earnings". All fields are combined with a logical 'AND'.
  """
  input earnings_bool_exp {
    _and: [earnings_bool_exp!]
    _not: earnings_bool_exp
    _or: [earnings_bool_exp!]
    amount: numeric_comparison_exp
    contractId: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    groupId: String_comparison_exp
    id: String_comparison_exp
    list: lists_bool_exp
    listId: String_comparison_exp
    offerId: String_comparison_exp
    receiverId: String_comparison_exp
    token: tokens_bool_exp
    tokenKey: String_comparison_exp
  }
  "aggregate max on columns"
  type earnings_max_fields {
    amount: numeric
    contractId: String
    createdAt: timestamptz
    groupId: String
    id: String
    listId: String
    offerId: String
    receiverId: String
    tokenKey: String
  }
  "aggregate min on columns"
  type earnings_min_fields {
    amount: numeric
    contractId: String
    createdAt: timestamptz
    groupId: String
    id: String
    listId: String
    offerId: String
    receiverId: String
    tokenKey: String
  }
  """
  Ordering options when selecting data from "earnings".
  """
  input earnings_order_by {
    amount: order_by
    contractId: order_by
    createdAt: order_by
    groupId: order_by
    id: order_by
    list: lists_order_by
    listId: order_by
    offerId: order_by
    receiverId: order_by
    token: tokens_order_by
    tokenKey: order_by
  }
  """
  select columns of table "earnings"
  """
  enum earnings_select_column {
    "column name"
    amount
    "column name"
    contractId
    "column name"
    createdAt
    "column name"
    groupId
    "column name"
    id
    "column name"
    listId
    "column name"
    offerId
    "column name"
    receiverId
    "column name"
    tokenKey
  }
  "aggregate stddev on columns"
  type earnings_stddev_fields {
    amount: Float
  }
  "aggregate stddev_pop on columns"
  type earnings_stddev_pop_fields {
    amount: Float
  }
  "aggregate stddev_samp on columns"
  type earnings_stddev_samp_fields {
    amount: Float
  }
  "aggregate sum on columns"
  type earnings_sum_fields {
    amount: numeric
  }
  "aggregate var_pop on columns"
  type earnings_var_pop_fields {
    amount: Float
  }
  "aggregate var_samp on columns"
  type earnings_var_samp_fields {
    amount: Float
  }
  "aggregate variance on columns"
  type earnings_variance_fields {
    amount: Float
  }
  """
  columns and relationships of "indexers"
  """
  type indexers {
    blockHeight: numeric!
    id: Int!
    network: String!
    status: String!
    syncedBlock: String!
  }
  """
  Boolean expression to filter rows from the table "indexers". All fields are combined with a logical 'AND'.
  """
  input indexers_bool_exp {
    _and: [indexers_bool_exp!]
    _not: indexers_bool_exp
    _or: [indexers_bool_exp!]
    blockHeight: numeric_comparison_exp
    id: Int_comparison_exp
    network: String_comparison_exp
    status: String_comparison_exp
    syncedBlock: String_comparison_exp
  }
  """
  Ordering options when selecting data from "indexers".
  """
  input indexers_order_by {
    blockHeight: order_by
    id: order_by
    network: order_by
    status: order_by
    syncedBlock: order_by
  }
  """
  select columns of table "indexers"
  """
  enum indexers_select_column {
    "column name"
    blockHeight
    "column name"
    id
    "column name"
    network
    "column name"
    status
    "column name"
    syncedBlock
  }
  scalar jsonb
  """
  Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
  """
  input jsonb_comparison_exp {
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
  }
  """
  columns and relationships of "lists"
  """
  type lists {
    acceptedOfferId: String
    autotransfer: Boolean!
    contractId: String!
    createdAt: timestamptz!
    currentOfferId: String
    groupId: String
    id: String!
    "An object relationship"
    offer: offers
    "An array relationship"
    offers("distinct select on columns" distinct_on: [offers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [offers_order_by!], "filter the rows returned" where: offers_bool_exp): [offers!]!
    "An aggregate relationship"
    offers_aggregate("distinct select on columns" distinct_on: [offers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [offers_order_by!], "filter the rows returned" where: offers_bool_exp): offers_aggregate!
    ownerId: String!
    price: numeric
    removedAt: timestamptz
    "An array relationship"
    royaltys("distinct select on columns" distinct_on: [royaltys_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [royaltys_order_by!], "filter the rows returned" where: royaltys_bool_exp): [royaltys!]!
    "An aggregate relationship"
    royaltys_aggregate("distinct select on columns" distinct_on: [royaltys_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [royaltys_order_by!], "filter the rows returned" where: royaltys_bool_exp): royaltys_aggregate!
    "An object relationship"
    token: tokens
    tokenKey: String!
    withdrawalEnable: Boolean
  }
  """
  aggregated selection of "lists"
  """
  type lists_aggregate {
    aggregate: lists_aggregate_fields
    nodes: [lists!]!
  }
  """
  aggregate fields of "lists"
  """
  type lists_aggregate_fields {
    avg: lists_avg_fields
    count(columns: [lists_select_column!], distinct: Boolean): Int!
    max: lists_max_fields
    min: lists_min_fields
    stddev: lists_stddev_fields
    stddev_pop: lists_stddev_pop_fields
    stddev_samp: lists_stddev_samp_fields
    sum: lists_sum_fields
    var_pop: lists_var_pop_fields
    var_samp: lists_var_samp_fields
    variance: lists_variance_fields
  }
  """
  order by aggregate values of table "lists"
  """
  input lists_aggregate_order_by {
    avg: lists_avg_order_by
    count: order_by
    max: lists_max_order_by
    min: lists_min_order_by
    stddev: lists_stddev_order_by
    stddev_pop: lists_stddev_pop_order_by
    stddev_samp: lists_stddev_samp_order_by
    sum: lists_sum_order_by
    var_pop: lists_var_pop_order_by
    var_samp: lists_var_samp_order_by
    variance: lists_variance_order_by
  }
  "aggregate avg on columns"
  type lists_avg_fields {
    price: Float
  }
  """
  order by avg() on columns of table "lists"
  """
  input lists_avg_order_by {
    price: order_by
  }
  """
  Boolean expression to filter rows from the table "lists". All fields are combined with a logical 'AND'.
  """
  input lists_bool_exp {
    _and: [lists_bool_exp!]
    _not: lists_bool_exp
    _or: [lists_bool_exp!]
    acceptedOfferId: String_comparison_exp
    autotransfer: Boolean_comparison_exp
    contractId: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    currentOfferId: String_comparison_exp
    groupId: String_comparison_exp
    id: String_comparison_exp
    offer: offers_bool_exp
    offers: offers_bool_exp
    ownerId: String_comparison_exp
    price: numeric_comparison_exp
    removedAt: timestamptz_comparison_exp
    royaltys: royaltys_bool_exp
    token: tokens_bool_exp
    tokenKey: String_comparison_exp
    withdrawalEnable: Boolean_comparison_exp
  }
  "aggregate max on columns"
  type lists_max_fields {
    acceptedOfferId: String
    contractId: String
    createdAt: timestamptz
    currentOfferId: String
    groupId: String
    id: String
    ownerId: String
    price: numeric
    removedAt: timestamptz
    tokenKey: String
  }
  """
  order by max() on columns of table "lists"
  """
  input lists_max_order_by {
    acceptedOfferId: order_by
    contractId: order_by
    createdAt: order_by
    currentOfferId: order_by
    groupId: order_by
    id: order_by
    ownerId: order_by
    price: order_by
    removedAt: order_by
    tokenKey: order_by
  }
  "aggregate min on columns"
  type lists_min_fields {
    acceptedOfferId: String
    contractId: String
    createdAt: timestamptz
    currentOfferId: String
    groupId: String
    id: String
    ownerId: String
    price: numeric
    removedAt: timestamptz
    tokenKey: String
  }
  """
  order by min() on columns of table "lists"
  """
  input lists_min_order_by {
    acceptedOfferId: order_by
    contractId: order_by
    createdAt: order_by
    currentOfferId: order_by
    groupId: order_by
    id: order_by
    ownerId: order_by
    price: order_by
    removedAt: order_by
    tokenKey: order_by
  }
  """
  Ordering options when selecting data from "lists".
  """
  input lists_order_by {
    acceptedOfferId: order_by
    autotransfer: order_by
    contractId: order_by
    createdAt: order_by
    currentOfferId: order_by
    groupId: order_by
    id: order_by
    offer: offers_order_by
    offers_aggregate: offers_aggregate_order_by
    ownerId: order_by
    price: order_by
    removedAt: order_by
    royaltys_aggregate: royaltys_aggregate_order_by
    token: tokens_order_by
    tokenKey: order_by
    withdrawalEnable: order_by
  }
  """
  select columns of table "lists"
  """
  enum lists_select_column {
    "column name"
    acceptedOfferId
    "column name"
    autotransfer
    "column name"
    contractId
    "column name"
    createdAt
    "column name"
    currentOfferId
    "column name"
    groupId
    "column name"
    id
    "column name"
    ownerId
    "column name"
    price
    "column name"
    removedAt
    "column name"
    tokenKey
    "column name"
    withdrawalEnable
  }
  "aggregate stddev on columns"
  type lists_stddev_fields {
    price: Float
  }
  """
  order by stddev() on columns of table "lists"
  """
  input lists_stddev_order_by {
    price: order_by
  }
  "aggregate stddev_pop on columns"
  type lists_stddev_pop_fields {
    price: Float
  }
  """
  order by stddev_pop() on columns of table "lists"
  """
  input lists_stddev_pop_order_by {
    price: order_by
  }
  "aggregate stddev_samp on columns"
  type lists_stddev_samp_fields {
    price: Float
  }
  """
  order by stddev_samp() on columns of table "lists"
  """
  input lists_stddev_samp_order_by {
    price: order_by
  }
  "aggregate sum on columns"
  type lists_sum_fields {
    price: numeric
  }
  """
  order by sum() on columns of table "lists"
  """
  input lists_sum_order_by {
    price: order_by
  }
  "aggregate var_pop on columns"
  type lists_var_pop_fields {
    price: Float
  }
  """
  order by var_pop() on columns of table "lists"
  """
  input lists_var_pop_order_by {
    price: order_by
  }
  "aggregate var_samp on columns"
  type lists_var_samp_fields {
    price: Float
  }
  """
  order by var_samp() on columns of table "lists"
  """
  input lists_var_samp_order_by {
    price: order_by
  }
  "aggregate variance on columns"
  type lists_variance_fields {
    price: Float
  }
  """
  order by variance() on columns of table "lists"
  """
  input lists_variance_order_by {
    price: order_by
  }
  """
  columns and relationships of "markets"
  """
  type markets {
    createdAt: timestamptz!
    createdBy: String!
    id: uuid!
    isTopAuction: Boolean!
    isTopStore: Boolean!
    "An object relationship"
    list: lists
    listId: String!
    "An object relationship"
    thing: things
    thingId: String!
  }
  """
  aggregated selection of "markets"
  """
  type markets_aggregate {
    aggregate: markets_aggregate_fields
    nodes: [markets!]!
  }
  """
  aggregate fields of "markets"
  """
  type markets_aggregate_fields {
    count(columns: [markets_select_column!], distinct: Boolean): Int!
    max: markets_max_fields
    min: markets_min_fields
  }
  """
  Boolean expression to filter rows from the table "markets". All fields are combined with a logical 'AND'.
  """
  input markets_bool_exp {
    _and: [markets_bool_exp!]
    _not: markets_bool_exp
    _or: [markets_bool_exp!]
    createdAt: timestamptz_comparison_exp
    createdBy: String_comparison_exp
    id: uuid_comparison_exp
    isTopAuction: Boolean_comparison_exp
    isTopStore: Boolean_comparison_exp
    list: lists_bool_exp
    listId: String_comparison_exp
    thing: things_bool_exp
    thingId: String_comparison_exp
  }
  "aggregate max on columns"
  type markets_max_fields {
    createdAt: timestamptz
    createdBy: String
    id: uuid
    listId: String
    thingId: String
  }
  "aggregate min on columns"
  type markets_min_fields {
    createdAt: timestamptz
    createdBy: String
    id: uuid
    listId: String
    thingId: String
  }
  """
  Ordering options when selecting data from "markets".
  """
  input markets_order_by {
    createdAt: order_by
    createdBy: order_by
    id: order_by
    isTopAuction: order_by
    isTopStore: order_by
    list: lists_order_by
    listId: order_by
    thing: things_order_by
    thingId: order_by
  }
  """
  select columns of table "markets"
  """
  enum markets_select_column {
    "column name"
    createdAt
    "column name"
    createdBy
    "column name"
    id
    "column name"
    isTopAuction
    "column name"
    isTopStore
    "column name"
    listId
    "column name"
    thingId
  }
  """
  columns and relationships of "metadata"
  """
  type metadata {
    animation_hash: String
    animation_size: bigint
    animation_type: String
    animation_url: String
    category: String
    description: String
    document: String
    document_hash: String
    external_url: String
    extra("JSON select path" path: String): jsonb
    id: uuid!
    media: String
    media_hash: String
    media_size: bigint
    media_type: String
    tags("JSON select path" path: String): jsonb
    "An object relationship"
    thing: things!
    thing_id: String!
    title: String
    type: String
    visibility: String
    youtube_url: String
  }
  """
  aggregated selection of "metadata"
  """
  type metadata_aggregate {
    aggregate: metadata_aggregate_fields
    nodes: [metadata!]!
  }
  """
  aggregate fields of "metadata"
  """
  type metadata_aggregate_fields {
    avg: metadata_avg_fields
    count(columns: [metadata_select_column!], distinct: Boolean): Int!
    max: metadata_max_fields
    min: metadata_min_fields
    stddev: metadata_stddev_fields
    stddev_pop: metadata_stddev_pop_fields
    stddev_samp: metadata_stddev_samp_fields
    sum: metadata_sum_fields
    var_pop: metadata_var_pop_fields
    var_samp: metadata_var_samp_fields
    variance: metadata_variance_fields
  }
  "aggregate avg on columns"
  type metadata_avg_fields {
    animation_size: Float
    media_size: Float
  }
  """
  Boolean expression to filter rows from the table "metadata". All fields are combined with a logical 'AND'.
  """
  input metadata_bool_exp {
    _and: [metadata_bool_exp!]
    _not: metadata_bool_exp
    _or: [metadata_bool_exp!]
    animation_hash: String_comparison_exp
    animation_size: bigint_comparison_exp
    animation_type: String_comparison_exp
    animation_url: String_comparison_exp
    category: String_comparison_exp
    description: String_comparison_exp
    document: String_comparison_exp
    document_hash: String_comparison_exp
    external_url: String_comparison_exp
    extra: jsonb_comparison_exp
    id: uuid_comparison_exp
    media: String_comparison_exp
    media_hash: String_comparison_exp
    media_size: bigint_comparison_exp
    media_type: String_comparison_exp
    tags: jsonb_comparison_exp
    thing: things_bool_exp
    thing_id: String_comparison_exp
    title: String_comparison_exp
    type: String_comparison_exp
    visibility: String_comparison_exp
    youtube_url: String_comparison_exp
  }
  "aggregate max on columns"
  type metadata_max_fields {
    animation_hash: String
    animation_size: bigint
    animation_type: String
    animation_url: String
    category: String
    description: String
    document: String
    document_hash: String
    external_url: String
    id: uuid
    media: String
    media_hash: String
    media_size: bigint
    media_type: String
    thing_id: String
    title: String
    type: String
    visibility: String
    youtube_url: String
  }
  "aggregate min on columns"
  type metadata_min_fields {
    animation_hash: String
    animation_size: bigint
    animation_type: String
    animation_url: String
    category: String
    description: String
    document: String
    document_hash: String
    external_url: String
    id: uuid
    media: String
    media_hash: String
    media_size: bigint
    media_type: String
    thing_id: String
    title: String
    type: String
    visibility: String
    youtube_url: String
  }
  """
  Ordering options when selecting data from "metadata".
  """
  input metadata_order_by {
    animation_hash: order_by
    animation_size: order_by
    animation_type: order_by
    animation_url: order_by
    category: order_by
    description: order_by
    document: order_by
    document_hash: order_by
    external_url: order_by
    extra: order_by
    id: order_by
    media: order_by
    media_hash: order_by
    media_size: order_by
    media_type: order_by
    tags: order_by
    thing: things_order_by
    thing_id: order_by
    title: order_by
    type: order_by
    visibility: order_by
    youtube_url: order_by
  }
  """
  select columns of table "metadata"
  """
  enum metadata_select_column {
    "column name"
    animation_hash
    "column name"
    animation_size
    "column name"
    animation_type
    "column name"
    animation_url
    "column name"
    category
    "column name"
    description
    "column name"
    document
    "column name"
    document_hash
    "column name"
    external_url
    "column name"
    extra
    "column name"
    id
    "column name"
    media
    "column name"
    media_hash
    "column name"
    media_size
    "column name"
    media_type
    "column name"
    tags
    "column name"
    thing_id
    "column name"
    title
    "column name"
    type
    "column name"
    visibility
    "column name"
    youtube_url
  }
  "aggregate stddev on columns"
  type metadata_stddev_fields {
    animation_size: Float
    media_size: Float
  }
  "aggregate stddev_pop on columns"
  type metadata_stddev_pop_fields {
    animation_size: Float
    media_size: Float
  }
  "aggregate stddev_samp on columns"
  type metadata_stddev_samp_fields {
    animation_size: Float
    media_size: Float
  }
  "aggregate sum on columns"
  type metadata_sum_fields {
    animation_size: bigint
    media_size: bigint
  }
  "aggregate var_pop on columns"
  type metadata_var_pop_fields {
    animation_size: Float
    media_size: Float
  }
  "aggregate var_samp on columns"
  type metadata_var_samp_fields {
    animation_size: Float
    media_size: Float
  }
  "aggregate variance on columns"
  type metadata_variance_fields {
    animation_size: Float
    media_size: Float
  }
  """
  columns and relationships of "minters"
  """
  type minters {
    account: String!
    createdAt: timestamptz
    enabled: Boolean!
    id: String!
    storeId: String!
    txId: String
  }
  """
  aggregated selection of "minters"
  """
  type minters_aggregate {
    aggregate: minters_aggregate_fields
    nodes: [minters!]!
  }
  """
  aggregate fields of "minters"
  """
  type minters_aggregate_fields {
    count(columns: [minters_select_column!], distinct: Boolean): Int!
    max: minters_max_fields
    min: minters_min_fields
  }
  """
  order by aggregate values of table "minters"
  """
  input minters_aggregate_order_by {
    count: order_by
    max: minters_max_order_by
    min: minters_min_order_by
  }
  """
  Boolean expression to filter rows from the table "minters". All fields are combined with a logical 'AND'.
  """
  input minters_bool_exp {
    _and: [minters_bool_exp!]
    _not: minters_bool_exp
    _or: [minters_bool_exp!]
    account: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    enabled: Boolean_comparison_exp
    id: String_comparison_exp
    storeId: String_comparison_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type minters_max_fields {
    account: String
    createdAt: timestamptz
    id: String
    storeId: String
    txId: String
  }
  """
  order by max() on columns of table "minters"
  """
  input minters_max_order_by {
    account: order_by
    createdAt: order_by
    id: order_by
    storeId: order_by
    txId: order_by
  }
  "aggregate min on columns"
  type minters_min_fields {
    account: String
    createdAt: timestamptz
    id: String
    storeId: String
    txId: String
  }
  """
  order by min() on columns of table "minters"
  """
  input minters_min_order_by {
    account: order_by
    createdAt: order_by
    id: order_by
    storeId: order_by
    txId: order_by
  }
  """
  Ordering options when selecting data from "minters".
  """
  input minters_order_by {
    account: order_by
    createdAt: order_by
    enabled: order_by
    id: order_by
    storeId: order_by
    txId: order_by
  }
  """
  select columns of table "minters"
  """
  enum minters_select_column {
    "column name"
    account
    "column name"
    createdAt
    "column name"
    enabled
    "column name"
    id
    "column name"
    storeId
    "column name"
    txId
  }
  scalar numeric
  """
  Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
  """
  input numeric_comparison_exp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _is_null: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
  }
  """
  columns and relationships of "offers"
  """
  type offers {
    acceptedAt: timestamptz
    contractId: String
    createdAt: timestamptz!
    from: String!
    id: String!
    "An object relationship"
    list: lists
    listId: String!
    price: numeric
    removedAt: timestamptz
    timeout: timestamptz!
    "An object relationship"
    token: tokens
    tokenKey: String!
    txId: String!
  }
  """
  aggregated selection of "offers"
  """
  type offers_aggregate {
    aggregate: offers_aggregate_fields
    nodes: [offers!]!
  }
  """
  aggregate fields of "offers"
  """
  type offers_aggregate_fields {
    avg: offers_avg_fields
    count(columns: [offers_select_column!], distinct: Boolean): Int!
    max: offers_max_fields
    min: offers_min_fields
    stddev: offers_stddev_fields
    stddev_pop: offers_stddev_pop_fields
    stddev_samp: offers_stddev_samp_fields
    sum: offers_sum_fields
    var_pop: offers_var_pop_fields
    var_samp: offers_var_samp_fields
    variance: offers_variance_fields
  }
  """
  order by aggregate values of table "offers"
  """
  input offers_aggregate_order_by {
    avg: offers_avg_order_by
    count: order_by
    max: offers_max_order_by
    min: offers_min_order_by
    stddev: offers_stddev_order_by
    stddev_pop: offers_stddev_pop_order_by
    stddev_samp: offers_stddev_samp_order_by
    sum: offers_sum_order_by
    var_pop: offers_var_pop_order_by
    var_samp: offers_var_samp_order_by
    variance: offers_variance_order_by
  }
  "aggregate avg on columns"
  type offers_avg_fields {
    price: Float
  }
  """
  order by avg() on columns of table "offers"
  """
  input offers_avg_order_by {
    price: order_by
  }
  """
  Boolean expression to filter rows from the table "offers". All fields are combined with a logical 'AND'.
  """
  input offers_bool_exp {
    _and: [offers_bool_exp!]
    _not: offers_bool_exp
    _or: [offers_bool_exp!]
    acceptedAt: timestamptz_comparison_exp
    contractId: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    from: String_comparison_exp
    id: String_comparison_exp
    list: lists_bool_exp
    listId: String_comparison_exp
    price: numeric_comparison_exp
    removedAt: timestamptz_comparison_exp
    timeout: timestamptz_comparison_exp
    token: tokens_bool_exp
    tokenKey: String_comparison_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type offers_max_fields {
    acceptedAt: timestamptz
    contractId: String
    createdAt: timestamptz
    from: String
    id: String
    listId: String
    price: numeric
    removedAt: timestamptz
    timeout: timestamptz
    tokenKey: String
    txId: String
  }
  """
  order by max() on columns of table "offers"
  """
  input offers_max_order_by {
    acceptedAt: order_by
    contractId: order_by
    createdAt: order_by
    from: order_by
    id: order_by
    listId: order_by
    price: order_by
    removedAt: order_by
    timeout: order_by
    tokenKey: order_by
    txId: order_by
  }
  "aggregate min on columns"
  type offers_min_fields {
    acceptedAt: timestamptz
    contractId: String
    createdAt: timestamptz
    from: String
    id: String
    listId: String
    price: numeric
    removedAt: timestamptz
    timeout: timestamptz
    tokenKey: String
    txId: String
  }
  """
  order by min() on columns of table "offers"
  """
  input offers_min_order_by {
    acceptedAt: order_by
    contractId: order_by
    createdAt: order_by
    from: order_by
    id: order_by
    listId: order_by
    price: order_by
    removedAt: order_by
    timeout: order_by
    tokenKey: order_by
    txId: order_by
  }
  """
  Ordering options when selecting data from "offers".
  """
  input offers_order_by {
    acceptedAt: order_by
    contractId: order_by
    createdAt: order_by
    from: order_by
    id: order_by
    list: lists_order_by
    listId: order_by
    price: order_by
    removedAt: order_by
    timeout: order_by
    token: tokens_order_by
    tokenKey: order_by
    txId: order_by
  }
  """
  select columns of table "offers"
  """
  enum offers_select_column {
    "column name"
    acceptedAt
    "column name"
    contractId
    "column name"
    createdAt
    "column name"
    from
    "column name"
    id
    "column name"
    listId
    "column name"
    price
    "column name"
    removedAt
    "column name"
    timeout
    "column name"
    tokenKey
    "column name"
    txId
  }
  "aggregate stddev on columns"
  type offers_stddev_fields {
    price: Float
  }
  """
  order by stddev() on columns of table "offers"
  """
  input offers_stddev_order_by {
    price: order_by
  }
  "aggregate stddev_pop on columns"
  type offers_stddev_pop_fields {
    price: Float
  }
  """
  order by stddev_pop() on columns of table "offers"
  """
  input offers_stddev_pop_order_by {
    price: order_by
  }
  "aggregate stddev_samp on columns"
  type offers_stddev_samp_fields {
    price: Float
  }
  """
  order by stddev_samp() on columns of table "offers"
  """
  input offers_stddev_samp_order_by {
    price: order_by
  }
  "aggregate sum on columns"
  type offers_sum_fields {
    price: numeric
  }
  """
  order by sum() on columns of table "offers"
  """
  input offers_sum_order_by {
    price: order_by
  }
  "aggregate var_pop on columns"
  type offers_var_pop_fields {
    price: Float
  }
  """
  order by var_pop() on columns of table "offers"
  """
  input offers_var_pop_order_by {
    price: order_by
  }
  "aggregate var_samp on columns"
  type offers_var_samp_fields {
    price: Float
  }
  """
  order by var_samp() on columns of table "offers"
  """
  input offers_var_samp_order_by {
    price: order_by
  }
  "aggregate variance on columns"
  type offers_variance_fields {
    price: Float
  }
  """
  order by variance() on columns of table "offers"
  """
  input offers_variance_order_by {
    price: order_by
  }
  "column ordering options"
  enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
  }
  type query_root {
    """
    fetch data from the table: "allowlists"
    """
    allowlists("distinct select on columns" distinct_on: [allowlists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [allowlists_order_by!], "filter the rows returned" where: allowlists_bool_exp): [allowlists!]!
    """
    fetch aggregated fields from the table: "allowlists"
    """
    allowlists_aggregate("distinct select on columns" distinct_on: [allowlists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [allowlists_order_by!], "filter the rows returned" where: allowlists_bool_exp): allowlists_aggregate!
    """
    fetch data from the table: "allowlists" using primary key columns
    """
    allowlists_by_pk(id: String!): allowlists
    "An array relationship"
    approvals("distinct select on columns" distinct_on: [approvals_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [approvals_order_by!], "filter the rows returned" where: approvals_bool_exp): [approvals!]!
    "An aggregate relationship"
    approvals_aggregate("distinct select on columns" distinct_on: [approvals_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [approvals_order_by!], "filter the rows returned" where: approvals_bool_exp): approvals_aggregate!
    """
    fetch data from the table: "approvals" using primary key columns
    """
    approvals_by_pk(id: String!): approvals
    """
    fetch data from the table: "banlists"
    """
    banlists("distinct select on columns" distinct_on: [banlists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [banlists_order_by!], "filter the rows returned" where: banlists_bool_exp): [banlists!]!
    """
    fetch aggregated fields from the table: "banlists"
    """
    banlists_aggregate("distinct select on columns" distinct_on: [banlists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [banlists_order_by!], "filter the rows returned" where: banlists_bool_exp): banlists_aggregate!
    """
    fetch data from the table: "banlists" using primary key columns
    """
    banlists_by_pk(id: String!): banlists
    """
    fetch data from the table: "earnings"
    """
    earnings("distinct select on columns" distinct_on: [earnings_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [earnings_order_by!], "filter the rows returned" where: earnings_bool_exp): [earnings!]!
    """
    fetch aggregated fields from the table: "earnings"
    """
    earnings_aggregate("distinct select on columns" distinct_on: [earnings_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [earnings_order_by!], "filter the rows returned" where: earnings_bool_exp): earnings_aggregate!
    """
    fetch data from the table: "earnings" using primary key columns
    """
    earnings_by_pk(id: String!): earnings
    """
    fetch data from the table: "indexers"
    """
    indexer("distinct select on columns" distinct_on: [indexers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [indexers_order_by!], "filter the rows returned" where: indexers_bool_exp): [indexers!]!
    """
    fetch data from the table: "lists"
    """
    list("distinct select on columns" distinct_on: [lists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [lists_order_by!], "filter the rows returned" where: lists_bool_exp): [lists!]!
    "An aggregate relationship"
    lists_aggregate("distinct select on columns" distinct_on: [lists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [lists_order_by!], "filter the rows returned" where: lists_bool_exp): lists_aggregate!
    """
    fetch data from the table: "lists" using primary key columns
    """
    lists_by_pk(id: String!): lists
    """
    fetch data from the table: "markets"
    """
    markets("distinct select on columns" distinct_on: [markets_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [markets_order_by!], "filter the rows returned" where: markets_bool_exp): [markets!]!
    """
    fetch aggregated fields from the table: "markets"
    """
    markets_aggregate("distinct select on columns" distinct_on: [markets_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [markets_order_by!], "filter the rows returned" where: markets_bool_exp): markets_aggregate!
    """
    fetch data from the table: "markets" using primary key columns
    """
    markets_by_pk(id: uuid!): markets
    """
    fetch data from the table: "metadata"
    """
    metadata("distinct select on columns" distinct_on: [metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [metadata_order_by!], "filter the rows returned" where: metadata_bool_exp): [metadata!]!
    """
    fetch aggregated fields from the table: "metadata"
    """
    metadata_aggregate("distinct select on columns" distinct_on: [metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [metadata_order_by!], "filter the rows returned" where: metadata_bool_exp): metadata_aggregate!
    """
    fetch data from the table: "metadata" using primary key columns
    """
    metadata_by_pk(id: uuid!): metadata
    """
    fetch data from the table: "minters"
    """
    minter("distinct select on columns" distinct_on: [minters_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [minters_order_by!], "filter the rows returned" where: minters_bool_exp): [minters!]!
    "An aggregate relationship"
    minters_aggregate("distinct select on columns" distinct_on: [minters_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [minters_order_by!], "filter the rows returned" where: minters_bool_exp): minters_aggregate!
    "An array relationship"
    offers("distinct select on columns" distinct_on: [offers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [offers_order_by!], "filter the rows returned" where: offers_bool_exp): [offers!]!
    "An aggregate relationship"
    offers_aggregate("distinct select on columns" distinct_on: [offers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [offers_order_by!], "filter the rows returned" where: offers_bool_exp): offers_aggregate!
    """
    fetch data from the table: "offers" using primary key columns
    """
    offers_by_pk(id: String!): offers
    "An array relationship"
    royaltys("distinct select on columns" distinct_on: [royaltys_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [royaltys_order_by!], "filter the rows returned" where: royaltys_bool_exp): [royaltys!]!
    "An aggregate relationship"
    royaltys_aggregate("distinct select on columns" distinct_on: [royaltys_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [royaltys_order_by!], "filter the rows returned" where: royaltys_bool_exp): royaltys_aggregate!
    """
    fetch data from the table: "royaltys" using primary key columns
    """
    royaltys_by_pk(id: String!): royaltys
    "An array relationship"
    splits("distinct select on columns" distinct_on: [splits_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [splits_order_by!], "filter the rows returned" where: splits_bool_exp): [splits!]!
    "An aggregate relationship"
    splits_aggregate("distinct select on columns" distinct_on: [splits_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [splits_order_by!], "filter the rows returned" where: splits_bool_exp): splits_aggregate!
    """
    fetch data from the table: "stores"
    """
    store("distinct select on columns" distinct_on: [stores_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [stores_order_by!], "filter the rows returned" where: stores_bool_exp): [stores!]!
    """
    fetch aggregated fields from the table: "stores"
    """
    stores_aggregate("distinct select on columns" distinct_on: [stores_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [stores_order_by!], "filter the rows returned" where: stores_bool_exp): stores_aggregate!
    """
    fetch data from the table: "stores" using primary key columns
    """
    stores_by_pk(id: String!): stores
    """
    fetch data from the table: "things"
    """
    thing("distinct select on columns" distinct_on: [things_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [things_order_by!], "filter the rows returned" where: things_bool_exp): [things!]!
    "An aggregate relationship"
    things_aggregate("distinct select on columns" distinct_on: [things_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [things_order_by!], "filter the rows returned" where: things_bool_exp): things_aggregate!
    """
    fetch data from the table: "tokens"
    """
    token("distinct select on columns" distinct_on: [tokens_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [tokens_order_by!], "filter the rows returned" where: tokens_bool_exp): [tokens!]!
    "An aggregate relationship"
    tokens_aggregate("distinct select on columns" distinct_on: [tokens_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [tokens_order_by!], "filter the rows returned" where: tokens_bool_exp): tokens_aggregate!
    """
    fetch data from the table: "tokens" using primary key columns
    """
    tokens_by_pk(id: String!): tokens
  }
  """
  columns and relationships of "royaltys"
  """
  type royaltys {
    account: String!
    groupId: String
    id: String!
    "An array relationship"
    lists("distinct select on columns" distinct_on: [lists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [lists_order_by!], "filter the rows returned" where: lists_bool_exp): [lists!]!
    "An aggregate relationship"
    lists_aggregate("distinct select on columns" distinct_on: [lists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [lists_order_by!], "filter the rows returned" where: lists_bool_exp): lists_aggregate!
    "An array relationship"
    offers("distinct select on columns" distinct_on: [offers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [offers_order_by!], "filter the rows returned" where: offers_bool_exp): [offers!]!
    "An aggregate relationship"
    offers_aggregate("distinct select on columns" distinct_on: [offers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [offers_order_by!], "filter the rows returned" where: offers_bool_exp): offers_aggregate!
    percent: Int
    "An object relationship"
    token: tokens
    txId: String
  }
  """
  aggregated selection of "royaltys"
  """
  type royaltys_aggregate {
    aggregate: royaltys_aggregate_fields
    nodes: [royaltys!]!
  }
  """
  aggregate fields of "royaltys"
  """
  type royaltys_aggregate_fields {
    avg: royaltys_avg_fields
    count(columns: [royaltys_select_column!], distinct: Boolean): Int!
    max: royaltys_max_fields
    min: royaltys_min_fields
    stddev: royaltys_stddev_fields
    stddev_pop: royaltys_stddev_pop_fields
    stddev_samp: royaltys_stddev_samp_fields
    sum: royaltys_sum_fields
    var_pop: royaltys_var_pop_fields
    var_samp: royaltys_var_samp_fields
    variance: royaltys_variance_fields
  }
  """
  order by aggregate values of table "royaltys"
  """
  input royaltys_aggregate_order_by {
    avg: royaltys_avg_order_by
    count: order_by
    max: royaltys_max_order_by
    min: royaltys_min_order_by
    stddev: royaltys_stddev_order_by
    stddev_pop: royaltys_stddev_pop_order_by
    stddev_samp: royaltys_stddev_samp_order_by
    sum: royaltys_sum_order_by
    var_pop: royaltys_var_pop_order_by
    var_samp: royaltys_var_samp_order_by
    variance: royaltys_variance_order_by
  }
  "aggregate avg on columns"
  type royaltys_avg_fields {
    percent: Float
  }
  """
  order by avg() on columns of table "royaltys"
  """
  input royaltys_avg_order_by {
    percent: order_by
  }
  """
  Boolean expression to filter rows from the table "royaltys". All fields are combined with a logical 'AND'.
  """
  input royaltys_bool_exp {
    _and: [royaltys_bool_exp!]
    _not: royaltys_bool_exp
    _or: [royaltys_bool_exp!]
    account: String_comparison_exp
    groupId: String_comparison_exp
    id: String_comparison_exp
    lists: lists_bool_exp
    offers: offers_bool_exp
    percent: Int_comparison_exp
    token: tokens_bool_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type royaltys_max_fields {
    account: String
    groupId: String
    id: String
    percent: Int
    txId: String
  }
  """
  order by max() on columns of table "royaltys"
  """
  input royaltys_max_order_by {
    account: order_by
    groupId: order_by
    id: order_by
    percent: order_by
    txId: order_by
  }
  "aggregate min on columns"
  type royaltys_min_fields {
    account: String
    groupId: String
    id: String
    percent: Int
    txId: String
  }
  """
  order by min() on columns of table "royaltys"
  """
  input royaltys_min_order_by {
    account: order_by
    groupId: order_by
    id: order_by
    percent: order_by
    txId: order_by
  }
  """
  Ordering options when selecting data from "royaltys".
  """
  input royaltys_order_by {
    account: order_by
    groupId: order_by
    id: order_by
    lists_aggregate: lists_aggregate_order_by
    offers_aggregate: offers_aggregate_order_by
    percent: order_by
    token: tokens_order_by
    txId: order_by
  }
  """
  select columns of table "royaltys"
  """
  enum royaltys_select_column {
    "column name"
    account
    "column name"
    groupId
    "column name"
    id
    "column name"
    percent
    "column name"
    txId
  }
  "aggregate stddev on columns"
  type royaltys_stddev_fields {
    percent: Float
  }
  """
  order by stddev() on columns of table "royaltys"
  """
  input royaltys_stddev_order_by {
    percent: order_by
  }
  "aggregate stddev_pop on columns"
  type royaltys_stddev_pop_fields {
    percent: Float
  }
  """
  order by stddev_pop() on columns of table "royaltys"
  """
  input royaltys_stddev_pop_order_by {
    percent: order_by
  }
  "aggregate stddev_samp on columns"
  type royaltys_stddev_samp_fields {
    percent: Float
  }
  """
  order by stddev_samp() on columns of table "royaltys"
  """
  input royaltys_stddev_samp_order_by {
    percent: order_by
  }
  "aggregate sum on columns"
  type royaltys_sum_fields {
    percent: Int
  }
  """
  order by sum() on columns of table "royaltys"
  """
  input royaltys_sum_order_by {
    percent: order_by
  }
  "aggregate var_pop on columns"
  type royaltys_var_pop_fields {
    percent: Float
  }
  """
  order by var_pop() on columns of table "royaltys"
  """
  input royaltys_var_pop_order_by {
    percent: order_by
  }
  "aggregate var_samp on columns"
  type royaltys_var_samp_fields {
    percent: Float
  }
  """
  order by var_samp() on columns of table "royaltys"
  """
  input royaltys_var_samp_order_by {
    percent: order_by
  }
  "aggregate variance on columns"
  type royaltys_variance_fields {
    percent: Float
  }
  """
  order by variance() on columns of table "royaltys"
  """
  input royaltys_variance_order_by {
    percent: order_by
  }
  """
  columns and relationships of "splits"
  """
  type splits {
    account: String!
    createdAt: timestamptz
    groupId: String
    id: String!
    percent: Int
    txId: String
  }
  """
  aggregated selection of "splits"
  """
  type splits_aggregate {
    aggregate: splits_aggregate_fields
    nodes: [splits!]!
  }
  """
  aggregate fields of "splits"
  """
  type splits_aggregate_fields {
    avg: splits_avg_fields
    count(columns: [splits_select_column!], distinct: Boolean): Int!
    max: splits_max_fields
    min: splits_min_fields
    stddev: splits_stddev_fields
    stddev_pop: splits_stddev_pop_fields
    stddev_samp: splits_stddev_samp_fields
    sum: splits_sum_fields
    var_pop: splits_var_pop_fields
    var_samp: splits_var_samp_fields
    variance: splits_variance_fields
  }
  """
  order by aggregate values of table "splits"
  """
  input splits_aggregate_order_by {
    avg: splits_avg_order_by
    count: order_by
    max: splits_max_order_by
    min: splits_min_order_by
    stddev: splits_stddev_order_by
    stddev_pop: splits_stddev_pop_order_by
    stddev_samp: splits_stddev_samp_order_by
    sum: splits_sum_order_by
    var_pop: splits_var_pop_order_by
    var_samp: splits_var_samp_order_by
    variance: splits_variance_order_by
  }
  "aggregate avg on columns"
  type splits_avg_fields {
    percent: Float
  }
  """
  order by avg() on columns of table "splits"
  """
  input splits_avg_order_by {
    percent: order_by
  }
  """
  Boolean expression to filter rows from the table "splits". All fields are combined with a logical 'AND'.
  """
  input splits_bool_exp {
    _and: [splits_bool_exp!]
    _not: splits_bool_exp
    _or: [splits_bool_exp!]
    account: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    groupId: String_comparison_exp
    id: String_comparison_exp
    percent: Int_comparison_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type splits_max_fields {
    account: String
    createdAt: timestamptz
    groupId: String
    id: String
    percent: Int
    txId: String
  }
  """
  order by max() on columns of table "splits"
  """
  input splits_max_order_by {
    account: order_by
    createdAt: order_by
    groupId: order_by
    id: order_by
    percent: order_by
    txId: order_by
  }
  "aggregate min on columns"
  type splits_min_fields {
    account: String
    createdAt: timestamptz
    groupId: String
    id: String
    percent: Int
    txId: String
  }
  """
  order by min() on columns of table "splits"
  """
  input splits_min_order_by {
    account: order_by
    createdAt: order_by
    groupId: order_by
    id: order_by
    percent: order_by
    txId: order_by
  }
  """
  Ordering options when selecting data from "splits".
  """
  input splits_order_by {
    account: order_by
    createdAt: order_by
    groupId: order_by
    id: order_by
    percent: order_by
    txId: order_by
  }
  """
  select columns of table "splits"
  """
  enum splits_select_column {
    "column name"
    account
    "column name"
    createdAt
    "column name"
    groupId
    "column name"
    id
    "column name"
    percent
    "column name"
    txId
  }
  "aggregate stddev on columns"
  type splits_stddev_fields {
    percent: Float
  }
  """
  order by stddev() on columns of table "splits"
  """
  input splits_stddev_order_by {
    percent: order_by
  }
  "aggregate stddev_pop on columns"
  type splits_stddev_pop_fields {
    percent: Float
  }
  """
  order by stddev_pop() on columns of table "splits"
  """
  input splits_stddev_pop_order_by {
    percent: order_by
  }
  "aggregate stddev_samp on columns"
  type splits_stddev_samp_fields {
    percent: Float
  }
  """
  order by stddev_samp() on columns of table "splits"
  """
  input splits_stddev_samp_order_by {
    percent: order_by
  }
  "aggregate sum on columns"
  type splits_sum_fields {
    percent: Int
  }
  """
  order by sum() on columns of table "splits"
  """
  input splits_sum_order_by {
    percent: order_by
  }
  "aggregate var_pop on columns"
  type splits_var_pop_fields {
    percent: Float
  }
  """
  order by var_pop() on columns of table "splits"
  """
  input splits_var_pop_order_by {
    percent: order_by
  }
  "aggregate var_samp on columns"
  type splits_var_samp_fields {
    percent: Float
  }
  """
  order by var_samp() on columns of table "splits"
  """
  input splits_var_samp_order_by {
    percent: order_by
  }
  "aggregate variance on columns"
  type splits_variance_fields {
    percent: Float
  }
  """
  order by variance() on columns of table "splits"
  """
  input splits_variance_order_by {
    percent: order_by
  }
  """
  columns and relationships of "stores"
  """
  type stores {
    baseUri: String
    createdAt: timestamptz!
    iconBase64: String
    id: String!
    is_external_contract: Boolean!
    "An array relationship"
    minters("distinct select on columns" distinct_on: [minters_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [minters_order_by!], "filter the rows returned" where: minters_bool_exp): [minters!]!
    "An aggregate relationship"
    minters_aggregate("distinct select on columns" distinct_on: [minters_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [minters_order_by!], "filter the rows returned" where: minters_bool_exp): minters_aggregate!
    name: String
    owner: String
    reference: String
    reference_hash: String
    spec: String
    symbol: String
    "An array relationship"
    things("distinct select on columns" distinct_on: [things_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [things_order_by!], "filter the rows returned" where: things_bool_exp): [things!]!
    "An aggregate relationship"
    things_aggregate("distinct select on columns" distinct_on: [things_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [things_order_by!], "filter the rows returned" where: things_bool_exp): things_aggregate!
    "An array relationship"
    tokens("distinct select on columns" distinct_on: [tokens_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [tokens_order_by!], "filter the rows returned" where: tokens_bool_exp): [tokens!]!
    "An aggregate relationship"
    tokens_aggregate("distinct select on columns" distinct_on: [tokens_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [tokens_order_by!], "filter the rows returned" where: tokens_bool_exp): tokens_aggregate!
    txId: String
  }
  """
  aggregated selection of "stores"
  """
  type stores_aggregate {
    aggregate: stores_aggregate_fields
    nodes: [stores!]!
  }
  """
  aggregate fields of "stores"
  """
  type stores_aggregate_fields {
    count(columns: [stores_select_column!], distinct: Boolean): Int!
    max: stores_max_fields
    min: stores_min_fields
  }
  """
  Boolean expression to filter rows from the table "stores". All fields are combined with a logical 'AND'.
  """
  input stores_bool_exp {
    _and: [stores_bool_exp!]
    _not: stores_bool_exp
    _or: [stores_bool_exp!]
    baseUri: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    iconBase64: String_comparison_exp
    id: String_comparison_exp
    is_external_contract: Boolean_comparison_exp
    minters: minters_bool_exp
    name: String_comparison_exp
    owner: String_comparison_exp
    reference: String_comparison_exp
    reference_hash: String_comparison_exp
    spec: String_comparison_exp
    symbol: String_comparison_exp
    things: things_bool_exp
    tokens: tokens_bool_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type stores_max_fields {
    baseUri: String
    createdAt: timestamptz
    iconBase64: String
    id: String
    name: String
    owner: String
    reference: String
    reference_hash: String
    spec: String
    symbol: String
    txId: String
  }
  "aggregate min on columns"
  type stores_min_fields {
    baseUri: String
    createdAt: timestamptz
    iconBase64: String
    id: String
    name: String
    owner: String
    reference: String
    reference_hash: String
    spec: String
    symbol: String
    txId: String
  }
  """
  Ordering options when selecting data from "stores".
  """
  input stores_order_by {
    baseUri: order_by
    createdAt: order_by
    iconBase64: order_by
    id: order_by
    is_external_contract: order_by
    minters_aggregate: minters_aggregate_order_by
    name: order_by
    owner: order_by
    reference: order_by
    reference_hash: order_by
    spec: order_by
    symbol: order_by
    things_aggregate: things_aggregate_order_by
    tokens_aggregate: tokens_aggregate_order_by
    txId: order_by
  }
  """
  select columns of table "stores"
  """
  enum stores_select_column {
    "column name"
    baseUri
    "column name"
    createdAt
    "column name"
    iconBase64
    "column name"
    id
    "column name"
    is_external_contract
    "column name"
    name
    "column name"
    owner
    "column name"
    reference
    "column name"
    reference_hash
    "column name"
    spec
    "column name"
    symbol
    "column name"
    txId
  }
  type subscription_root {
    """
    fetch data from the table: "allowlists"
    """
    allowlists("distinct select on columns" distinct_on: [allowlists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [allowlists_order_by!], "filter the rows returned" where: allowlists_bool_exp): [allowlists!]!
    """
    fetch aggregated fields from the table: "allowlists"
    """
    allowlists_aggregate("distinct select on columns" distinct_on: [allowlists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [allowlists_order_by!], "filter the rows returned" where: allowlists_bool_exp): allowlists_aggregate!
    """
    fetch data from the table: "allowlists" using primary key columns
    """
    allowlists_by_pk(id: String!): allowlists
    "An array relationship"
    approvals("distinct select on columns" distinct_on: [approvals_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [approvals_order_by!], "filter the rows returned" where: approvals_bool_exp): [approvals!]!
    "An aggregate relationship"
    approvals_aggregate("distinct select on columns" distinct_on: [approvals_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [approvals_order_by!], "filter the rows returned" where: approvals_bool_exp): approvals_aggregate!
    """
    fetch data from the table: "approvals" using primary key columns
    """
    approvals_by_pk(id: String!): approvals
    """
    fetch data from the table: "banlists"
    """
    banlists("distinct select on columns" distinct_on: [banlists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [banlists_order_by!], "filter the rows returned" where: banlists_bool_exp): [banlists!]!
    """
    fetch aggregated fields from the table: "banlists"
    """
    banlists_aggregate("distinct select on columns" distinct_on: [banlists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [banlists_order_by!], "filter the rows returned" where: banlists_bool_exp): banlists_aggregate!
    """
    fetch data from the table: "banlists" using primary key columns
    """
    banlists_by_pk(id: String!): banlists
    """
    fetch data from the table: "earnings"
    """
    earnings("distinct select on columns" distinct_on: [earnings_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [earnings_order_by!], "filter the rows returned" where: earnings_bool_exp): [earnings!]!
    """
    fetch aggregated fields from the table: "earnings"
    """
    earnings_aggregate("distinct select on columns" distinct_on: [earnings_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [earnings_order_by!], "filter the rows returned" where: earnings_bool_exp): earnings_aggregate!
    """
    fetch data from the table: "earnings" using primary key columns
    """
    earnings_by_pk(id: String!): earnings
    """
    fetch data from the table: "indexers"
    """
    indexer("distinct select on columns" distinct_on: [indexers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [indexers_order_by!], "filter the rows returned" where: indexers_bool_exp): [indexers!]!
    """
    fetch data from the table: "lists"
    """
    list("distinct select on columns" distinct_on: [lists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [lists_order_by!], "filter the rows returned" where: lists_bool_exp): [lists!]!
    "An aggregate relationship"
    lists_aggregate("distinct select on columns" distinct_on: [lists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [lists_order_by!], "filter the rows returned" where: lists_bool_exp): lists_aggregate!
    """
    fetch data from the table: "lists" using primary key columns
    """
    lists_by_pk(id: String!): lists
    """
    fetch data from the table: "markets"
    """
    markets("distinct select on columns" distinct_on: [markets_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [markets_order_by!], "filter the rows returned" where: markets_bool_exp): [markets!]!
    """
    fetch aggregated fields from the table: "markets"
    """
    markets_aggregate("distinct select on columns" distinct_on: [markets_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [markets_order_by!], "filter the rows returned" where: markets_bool_exp): markets_aggregate!
    """
    fetch data from the table: "markets" using primary key columns
    """
    markets_by_pk(id: uuid!): markets
    """
    fetch data from the table: "metadata"
    """
    metadata("distinct select on columns" distinct_on: [metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [metadata_order_by!], "filter the rows returned" where: metadata_bool_exp): [metadata!]!
    """
    fetch aggregated fields from the table: "metadata"
    """
    metadata_aggregate("distinct select on columns" distinct_on: [metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [metadata_order_by!], "filter the rows returned" where: metadata_bool_exp): metadata_aggregate!
    """
    fetch data from the table: "metadata" using primary key columns
    """
    metadata_by_pk(id: uuid!): metadata
    """
    fetch data from the table: "minters"
    """
    minter("distinct select on columns" distinct_on: [minters_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [minters_order_by!], "filter the rows returned" where: minters_bool_exp): [minters!]!
    "An aggregate relationship"
    minters_aggregate("distinct select on columns" distinct_on: [minters_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [minters_order_by!], "filter the rows returned" where: minters_bool_exp): minters_aggregate!
    "An array relationship"
    offers("distinct select on columns" distinct_on: [offers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [offers_order_by!], "filter the rows returned" where: offers_bool_exp): [offers!]!
    "An aggregate relationship"
    offers_aggregate("distinct select on columns" distinct_on: [offers_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [offers_order_by!], "filter the rows returned" where: offers_bool_exp): offers_aggregate!
    """
    fetch data from the table: "offers" using primary key columns
    """
    offers_by_pk(id: String!): offers
    "An array relationship"
    royaltys("distinct select on columns" distinct_on: [royaltys_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [royaltys_order_by!], "filter the rows returned" where: royaltys_bool_exp): [royaltys!]!
    "An aggregate relationship"
    royaltys_aggregate("distinct select on columns" distinct_on: [royaltys_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [royaltys_order_by!], "filter the rows returned" where: royaltys_bool_exp): royaltys_aggregate!
    """
    fetch data from the table: "royaltys" using primary key columns
    """
    royaltys_by_pk(id: String!): royaltys
    "An array relationship"
    splits("distinct select on columns" distinct_on: [splits_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [splits_order_by!], "filter the rows returned" where: splits_bool_exp): [splits!]!
    "An aggregate relationship"
    splits_aggregate("distinct select on columns" distinct_on: [splits_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [splits_order_by!], "filter the rows returned" where: splits_bool_exp): splits_aggregate!
    """
    fetch data from the table: "stores"
    """
    store("distinct select on columns" distinct_on: [stores_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [stores_order_by!], "filter the rows returned" where: stores_bool_exp): [stores!]!
    """
    fetch aggregated fields from the table: "stores"
    """
    stores_aggregate("distinct select on columns" distinct_on: [stores_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [stores_order_by!], "filter the rows returned" where: stores_bool_exp): stores_aggregate!
    """
    fetch data from the table: "stores" using primary key columns
    """
    stores_by_pk(id: String!): stores
    """
    fetch data from the table: "things"
    """
    thing("distinct select on columns" distinct_on: [things_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [things_order_by!], "filter the rows returned" where: things_bool_exp): [things!]!
    "An aggregate relationship"
    things_aggregate("distinct select on columns" distinct_on: [things_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [things_order_by!], "filter the rows returned" where: things_bool_exp): things_aggregate!
    """
    fetch data from the table: "tokens"
    """
    token("distinct select on columns" distinct_on: [tokens_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [tokens_order_by!], "filter the rows returned" where: tokens_bool_exp): [tokens!]!
    "An aggregate relationship"
    tokens_aggregate("distinct select on columns" distinct_on: [tokens_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [tokens_order_by!], "filter the rows returned" where: tokens_bool_exp): tokens_aggregate!
    """
    fetch data from the table: "tokens" using primary key columns
    """
    tokens_by_pk(id: String!): tokens
  }
  """
  A THING I AM
  
  
  columns and relationships of "things"
  
  """
  type things {
    createdAt: timestamptz
    id: String!
    memo: String
    metaId: String
    "An object relationship"
    metadata: metadata
    "An object relationship"
    store: stores
    storeId: String!
    "An array relationship"
    tokens("distinct select on columns" distinct_on: [tokens_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [tokens_order_by!], "filter the rows returned" where: tokens_bool_exp): [tokens!]!
    "An aggregate relationship"
    tokens_aggregate("distinct select on columns" distinct_on: [tokens_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [tokens_order_by!], "filter the rows returned" where: tokens_bool_exp): tokens_aggregate!
  }
  """
  aggregated selection of "things"
  """
  type things_aggregate {
    aggregate: things_aggregate_fields
    nodes: [things!]!
  }
  """
  aggregate fields of "things"
  """
  type things_aggregate_fields {
    count(columns: [things_select_column!], distinct: Boolean): Int!
    max: things_max_fields
    min: things_min_fields
  }
  """
  order by aggregate values of table "things"
  """
  input things_aggregate_order_by {
    count: order_by
    max: things_max_order_by
    min: things_min_order_by
  }
  """
  Boolean expression to filter rows from the table "things". All fields are combined with a logical 'AND'.
  """
  input things_bool_exp {
    _and: [things_bool_exp!]
    _not: things_bool_exp
    _or: [things_bool_exp!]
    createdAt: timestamptz_comparison_exp
    id: String_comparison_exp
    memo: String_comparison_exp
    metaId: String_comparison_exp
    metadata: metadata_bool_exp
    store: stores_bool_exp
    storeId: String_comparison_exp
    tokens: tokens_bool_exp
  }
  "aggregate max on columns"
  type things_max_fields {
    createdAt: timestamptz
    id: String
    memo: String
    metaId: String
    storeId: String
  }
  """
  order by max() on columns of table "things"
  """
  input things_max_order_by {
    createdAt: order_by
    id: order_by
    memo: order_by
    metaId: order_by
    storeId: order_by
  }
  "aggregate min on columns"
  type things_min_fields {
    createdAt: timestamptz
    id: String
    memo: String
    metaId: String
    storeId: String
  }
  """
  order by min() on columns of table "things"
  """
  input things_min_order_by {
    createdAt: order_by
    id: order_by
    memo: order_by
    metaId: order_by
    storeId: order_by
  }
  """
  Ordering options when selecting data from "things".
  """
  input things_order_by {
    createdAt: order_by
    id: order_by
    memo: order_by
    metaId: order_by
    metadata: metadata_order_by
    store: stores_order_by
    storeId: order_by
    tokens_aggregate: tokens_aggregate_order_by
  }
  """
  select columns of table "things"
  """
  enum things_select_column {
    "column name"
    createdAt
    "column name"
    id
    "column name"
    memo
    "column name"
    metaId
    "column name"
    storeId
  }
  scalar timestamptz
  """
  Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
  """
  input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
  }
  """
  columns and relationships of "tokens"
  """
  type tokens {
    "An array relationship"
    approvals("distinct select on columns" distinct_on: [approvals_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [approvals_order_by!], "filter the rows returned" where: approvals_bool_exp): [approvals!]!
    "An aggregate relationship"
    approvals_aggregate("distinct select on columns" distinct_on: [approvals_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [approvals_order_by!], "filter the rows returned" where: approvals_bool_exp): approvals_aggregate!
    burnedAt: timestamptz
    createdAt: timestamptz!
    crossHolder: String
    crossRootKey: String
    depth: Int
    holder: String
    id: String!
    lastTransferred: timestamptz!
    "An object relationship"
    list: lists
    "An array relationship"
    lists("distinct select on columns" distinct_on: [lists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [lists_order_by!], "filter the rows returned" where: lists_bool_exp): [lists!]!
    "An aggregate relationship"
    lists_aggregate("distinct select on columns" distinct_on: [lists_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [lists_order_by!], "filter the rows returned" where: lists_bool_exp): lists_aggregate!
    loan: String
    localRootKey: String
    mintGroupId: String
    minter: String
    originKey: String
    ownerId: String
    ownerType: String
    royaltyPercent: Int
    "An array relationship"
    royaltys("distinct select on columns" distinct_on: [royaltys_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [royaltys_order_by!], "filter the rows returned" where: royaltys_bool_exp): [royaltys!]!
    "An aggregate relationship"
    royaltys_aggregate("distinct select on columns" distinct_on: [royaltys_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [royaltys_order_by!], "filter the rows returned" where: royaltys_bool_exp): royaltys_aggregate!
    splitGroupId: String
    "An array relationship"
    splits("distinct select on columns" distinct_on: [splits_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [splits_order_by!], "filter the rows returned" where: splits_bool_exp): [splits!]!
    "An aggregate relationship"
    splits_aggregate("distinct select on columns" distinct_on: [splits_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [splits_order_by!], "filter the rows returned" where: splits_bool_exp): splits_aggregate!
    "An object relationship"
    store: stores
    storeId: String
    "An object relationship"
    thing: things
    thingId: String
    txId: String
  }
  """
  aggregated selection of "tokens"
  """
  type tokens_aggregate {
    aggregate: tokens_aggregate_fields
    nodes: [tokens!]!
  }
  """
  aggregate fields of "tokens"
  """
  type tokens_aggregate_fields {
    avg: tokens_avg_fields
    count(columns: [tokens_select_column!], distinct: Boolean): Int!
    max: tokens_max_fields
    min: tokens_min_fields
    stddev: tokens_stddev_fields
    stddev_pop: tokens_stddev_pop_fields
    stddev_samp: tokens_stddev_samp_fields
    sum: tokens_sum_fields
    var_pop: tokens_var_pop_fields
    var_samp: tokens_var_samp_fields
    variance: tokens_variance_fields
  }
  """
  order by aggregate values of table "tokens"
  """
  input tokens_aggregate_order_by {
    avg: tokens_avg_order_by
    count: order_by
    max: tokens_max_order_by
    min: tokens_min_order_by
    stddev: tokens_stddev_order_by
    stddev_pop: tokens_stddev_pop_order_by
    stddev_samp: tokens_stddev_samp_order_by
    sum: tokens_sum_order_by
    var_pop: tokens_var_pop_order_by
    var_samp: tokens_var_samp_order_by
    variance: tokens_variance_order_by
  }
  "aggregate avg on columns"
  type tokens_avg_fields {
    depth: Float
    royaltyPercent: Float
  }
  """
  order by avg() on columns of table "tokens"
  """
  input tokens_avg_order_by {
    depth: order_by
    royaltyPercent: order_by
  }
  """
  Boolean expression to filter rows from the table "tokens". All fields are combined with a logical 'AND'.
  """
  input tokens_bool_exp {
    _and: [tokens_bool_exp!]
    _not: tokens_bool_exp
    _or: [tokens_bool_exp!]
    approvals: approvals_bool_exp
    burnedAt: timestamptz_comparison_exp
    createdAt: timestamptz_comparison_exp
    crossHolder: String_comparison_exp
    crossRootKey: String_comparison_exp
    depth: Int_comparison_exp
    holder: String_comparison_exp
    id: String_comparison_exp
    lastTransferred: timestamptz_comparison_exp
    list: lists_bool_exp
    lists: lists_bool_exp
    loan: String_comparison_exp
    localRootKey: String_comparison_exp
    mintGroupId: String_comparison_exp
    minter: String_comparison_exp
    originKey: String_comparison_exp
    ownerId: String_comparison_exp
    ownerType: String_comparison_exp
    royaltyPercent: Int_comparison_exp
    royaltys: royaltys_bool_exp
    splitGroupId: String_comparison_exp
    splits: splits_bool_exp
    store: stores_bool_exp
    storeId: String_comparison_exp
    thing: things_bool_exp
    thingId: String_comparison_exp
    txId: String_comparison_exp
  }
  "aggregate max on columns"
  type tokens_max_fields {
    burnedAt: timestamptz
    createdAt: timestamptz
    crossHolder: String
    crossRootKey: String
    depth: Int
    holder: String
    id: String
    lastTransferred: timestamptz
    loan: String
    localRootKey: String
    mintGroupId: String
    minter: String
    originKey: String
    ownerId: String
    ownerType: String
    royaltyPercent: Int
    splitGroupId: String
    storeId: String
    thingId: String
    txId: String
  }
  """
  order by max() on columns of table "tokens"
  """
  input tokens_max_order_by {
    burnedAt: order_by
    createdAt: order_by
    crossHolder: order_by
    crossRootKey: order_by
    depth: order_by
    holder: order_by
    id: order_by
    lastTransferred: order_by
    loan: order_by
    localRootKey: order_by
    mintGroupId: order_by
    minter: order_by
    originKey: order_by
    ownerId: order_by
    ownerType: order_by
    royaltyPercent: order_by
    splitGroupId: order_by
    storeId: order_by
    thingId: order_by
    txId: order_by
  }
  "aggregate min on columns"
  type tokens_min_fields {
    burnedAt: timestamptz
    createdAt: timestamptz
    crossHolder: String
    crossRootKey: String
    depth: Int
    holder: String
    id: String
    lastTransferred: timestamptz
    loan: String
    localRootKey: String
    mintGroupId: String
    minter: String
    originKey: String
    ownerId: String
    ownerType: String
    royaltyPercent: Int
    splitGroupId: String
    storeId: String
    thingId: String
    txId: String
  }
  """
  order by min() on columns of table "tokens"
  """
  input tokens_min_order_by {
    burnedAt: order_by
    createdAt: order_by
    crossHolder: order_by
    crossRootKey: order_by
    depth: order_by
    holder: order_by
    id: order_by
    lastTransferred: order_by
    loan: order_by
    localRootKey: order_by
    mintGroupId: order_by
    minter: order_by
    originKey: order_by
    ownerId: order_by
    ownerType: order_by
    royaltyPercent: order_by
    splitGroupId: order_by
    storeId: order_by
    thingId: order_by
    txId: order_by
  }
  """
  Ordering options when selecting data from "tokens".
  """
  input tokens_order_by {
    approvals_aggregate: approvals_aggregate_order_by
    burnedAt: order_by
    createdAt: order_by
    crossHolder: order_by
    crossRootKey: order_by
    depth: order_by
    holder: order_by
    id: order_by
    lastTransferred: order_by
    list: lists_order_by
    lists_aggregate: lists_aggregate_order_by
    loan: order_by
    localRootKey: order_by
    mintGroupId: order_by
    minter: order_by
    originKey: order_by
    ownerId: order_by
    ownerType: order_by
    royaltyPercent: order_by
    royaltys_aggregate: royaltys_aggregate_order_by
    splitGroupId: order_by
    splits_aggregate: splits_aggregate_order_by
    store: stores_order_by
    storeId: order_by
    thing: things_order_by
    thingId: order_by
    txId: order_by
  }
  """
  select columns of table "tokens"
  """
  enum tokens_select_column {
    "column name"
    burnedAt
    "column name"
    createdAt
    "column name"
    crossHolder
    "column name"
    crossRootKey
    "column name"
    depth
    "column name"
    holder
    "column name"
    id
    "column name"
    lastTransferred
    "column name"
    loan
    "column name"
    localRootKey
    "column name"
    mintGroupId
    "column name"
    minter
    "column name"
    originKey
    "column name"
    ownerId
    "column name"
    ownerType
    "column name"
    royaltyPercent
    "column name"
    splitGroupId
    "column name"
    storeId
    "column name"
    thingId
    "column name"
    txId
  }
  "aggregate stddev on columns"
  type tokens_stddev_fields {
    depth: Float
    royaltyPercent: Float
  }
  """
  order by stddev() on columns of table "tokens"
  """
  input tokens_stddev_order_by {
    depth: order_by
    royaltyPercent: order_by
  }
  "aggregate stddev_pop on columns"
  type tokens_stddev_pop_fields {
    depth: Float
    royaltyPercent: Float
  }
  """
  order by stddev_pop() on columns of table "tokens"
  """
  input tokens_stddev_pop_order_by {
    depth: order_by
    royaltyPercent: order_by
  }
  "aggregate stddev_samp on columns"
  type tokens_stddev_samp_fields {
    depth: Float
    royaltyPercent: Float
  }
  """
  order by stddev_samp() on columns of table "tokens"
  """
  input tokens_stddev_samp_order_by {
    depth: order_by
    royaltyPercent: order_by
  }
  "aggregate sum on columns"
  type tokens_sum_fields {
    depth: Int
    royaltyPercent: Int
  }
  """
  order by sum() on columns of table "tokens"
  """
  input tokens_sum_order_by {
    depth: order_by
    royaltyPercent: order_by
  }
  "aggregate var_pop on columns"
  type tokens_var_pop_fields {
    depth: Float
    royaltyPercent: Float
  }
  """
  order by var_pop() on columns of table "tokens"
  """
  input tokens_var_pop_order_by {
    depth: order_by
    royaltyPercent: order_by
  }
  "aggregate var_samp on columns"
  type tokens_var_samp_fields {
    depth: Float
    royaltyPercent: Float
  }
  """
  order by var_samp() on columns of table "tokens"
  """
  input tokens_var_samp_order_by {
    depth: order_by
    royaltyPercent: order_by
  }
  "aggregate variance on columns"
  type tokens_variance_fields {
    depth: Float
    royaltyPercent: Float
  }
  """
  order by variance() on columns of table "tokens"
  """
  input tokens_variance_order_by {
    depth: order_by
    royaltyPercent: order_by
  }
  scalar uuid
  """
  Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
  """
  input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
  }
  